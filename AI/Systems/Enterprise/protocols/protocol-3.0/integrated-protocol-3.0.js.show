const { autoInitializeDashboard, getGlobalDashboard } = require('./auto-dashboard-initializer.js');
const { Phase11EnterprisePerformance } = require('./phases/phase-11-enterprise-performance.js');
const { VisualValidationSuite3_0 } = require('../../systems/Enterprise/visual-validation-suite-3.0.js');

class IntegratedProtocol30 {
  constructor() {
    this.dashboard = null;
    this.performanceAnalyzer = new Phase11EnterprisePerformance();
    this.visualValidator = new VisualValidationSuite3_0();
    try {
      const { Phase10ComprehensiveValidation } = require('./phases/phase-10-comprehensive-validation.js');
      this.validationAnalyzer = new Phase10ComprehensiveValidation();
    } catch {
      this.validationAnalyzer = null;
    }
    this.hooks = null;
  }

  // Main entry point - automatically initializes dashboard
  async cloneWebsite(targetUrl, options = {}) {
    try {
      // AUTOMATIC DASHBOARD INITIALIZATION
      console.log('ðŸš€ Initializing Protocol 3.0 with Enhanced Dashboard...\n');

      // Auto-initialize dashboard - this ALWAYS runs
      this.dashboard = autoInitializeDashboard(targetUrl);
      this.hooks = getGlobalDashboard().getIntegrationHooks();

      const projectName = options.projectName || this.extractProjectName(targetUrl);
      const projectPath = options.projectPath || this.generateProjectPath(projectName);

      // Ensure project directory exists
      await this.ensureProjectDirectory(projectPath);

      console.log(`ðŸŽ¯ TARGET: ${targetUrl}`);
      console.log(`ðŸ“ PROJECT: ${projectName}`);
      console.log(`ðŸ“‚ PATH: ${projectPath}\n`);

      // Runtime environment checks
      try { require('playwright'); console.log('Playwright: AVAILABLE'); } catch { console.log('Playwright: NOT INSTALLED'); }
      const mcpActive = typeof global.mcpVisualValidate === 'function';
      console.log(mcpActive ? 'MCP: ACTIVE' : 'MCP: NOT ACTIVE â€” using standard Playwright + diff fallback');

      // Execute Phase 1: generate and persist a Design Brief artifact
      await this.generateDesignBriefArtifact(projectPath, targetUrl);

      // Execute all phases with dashboard tracking
      const result = await this.executeAllPhases(targetUrl, projectPath, options);

      // Generate final report
      const finalReport = this.hooks.onSessionComplete();

      return {
        success: result.success,
        projectPath: projectPath,
        finalSimilarity: result.finalSimilarity,
        performanceGrade: result.performanceGrade,
        dashboardReport: finalReport
      };

    } catch (error) {
      console.error(`âŒ Protocol 3.0 failed: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // Execute all phases with integrated dashboard tracking
  async executeAllPhases(targetUrl, projectPath, options) {
    const phases = this.getPhaseDefinitions();
    let currentSimilarity = 0;
    let finalPerformanceGrade = 'PENDING';
    const finalTarget = parseInt(options.finalTargetSimilarity || process.env.ENT_FINAL_TARGET || '95', 10);

    // Enforce Stage â†’ Phase mapping unless overridden
    const stage = options.currentStage || parseInt(process.env.ENT_STAGE || '3', 10);
    const allowOutOfOrder = process.env.ENT_ALLOW_OUT_OF_ORDER === '1';

    const resumePhase = parseInt(options.resumePhase || process.env.ENT_RESUME_PHASE || '1', 10);
    for (let i = Math.max(0, resumePhase - 1); i < phases.length; i++) {
      const phase = phases[i];
      const phaseNumber = i + 1;

      // Prevent execution outside mapped stage unless explicitly allowed
      if (!allowOutOfOrder && stage === 3 && phaseNumber > 8) {
        console.log('\n[stage] Stage 3 allows Phases 1â€“8. Set ENT_STAGE=6 or ENT_ALLOW_OUT_OF_ORDER=1 to run further phases.');
        break;
      }

      // Notify dashboard of phase start
      this.hooks.onPhaseStart(phaseNumber, phase.name);

      console.log(`\n${'='.repeat(80)}`);
      console.log(`ðŸ”„ PHASE ${phaseNumber}: ${phase.name.toUpperCase()}`);
      console.log(`${'='.repeat(80)}`);

      const phaseStartTime = new Date();
      let phaseResult;

      try {
        // Execute phase based on type
        if (phaseNumber <= 10) {
          // Design phases (1-10)
          phaseResult = await this.executeDesignPhase(phaseNumber, phase, targetUrl, projectPath);
          if (phaseNumber === 10 && this.validationAnalyzer) {
            const v = await this.validationAnalyzer.executePhase10('http://localhost:3000');
            if (!v.passed) {
              phaseResult.success = false;
              phaseResult.issues = (phaseResult.issues || []).concat(v.issues || ['Validation failed']);
            }
          }
        } else {
          // Performance phase (11)
          phaseResult = await this.executePerformancePhase(projectPath);
          finalPerformanceGrade = phaseResult.overallGrade;
        }

        // Update current similarity
        if (phaseResult.similarity) {
          currentSimilarity = phaseResult.similarity;
        }

        // Record phase completion with dashboard
        this.hooks.onPhaseComplete(phaseNumber, {
          name: phase.name,
          startTime: phaseStartTime,
          duration: new Date() - phaseStartTime,
          similarity: phaseResult.similarity || currentSimilarity,
          iterations: phaseResult.iterations || 1,
          status: 'COMPLETED',
          issues: phaseResult.issues || [],
          improvements: phaseResult.improvements || []
        });

        // Check if we should continue
        if (!phaseResult.success && phase.required) {
          throw new Error(`Required phase ${phaseNumber} failed`);
        }

        // Early completion check
        if (phaseNumber >= 8 && currentSimilarity >= (options.targetSimilarity || 85)) {
          console.log(`\nðŸŽ¯ Target similarity ${options.targetSimilarity || 85}% achieved at Phase ${phaseNumber}!`);
          break;
        }

      } catch (error) {
        console.error(`âŒ Phase ${phaseNumber} failed: ${error.message}`);

        this.hooks.onPhaseComplete(phaseNumber, {
          name: phase.name,
          startTime: phaseStartTime,
          duration: new Date() - phaseStartTime,
          similarity: currentSimilarity,
          iterations: 1,
          status: 'FAILED',
          issues: [error.message],
          improvements: []
        });

        if (phase.required) {
          throw error;
        }
      }
    }

    return {
      success: currentSimilarity >= finalTarget,
      finalSimilarity: currentSimilarity,
      performanceGrade: finalPerformanceGrade
    };
  }

  // Execute design phase (Phases 1-10) with iteration tracking
  async executeDesignPhase(phaseNumber, phase, targetUrl, projectPath) {
    let iterations = 0;
    let similarity = 0;
    const maxIterations = 10;
    const improvements = [];
    const issues = [];

    while (iterations < maxIterations && similarity < phase.targetSimilarity) {
      iterations++;
      const iterationStart = new Date();

      console.log(`   ðŸ”„ Iteration ${iterations}/${maxIterations}`);

      try {
        // Simulate/execute actual phase work
        await this.executePhaseLogic(phaseNumber, iterations, projectPath);

        // Validate current state
        if (phaseNumber >= 2) { // Skip validation for design brief phase
          const evidenceDir = await this.ensureEvidenceDir(projectPath, phaseNumber, iterations);
          const ev = await this.captureEvidenceIfPossible('http://localhost:3000', targetUrl, evidenceDir);
          const validation = await this.visualValidator.runComprehensiveValidation(
            'http://localhost:3000',
            targetUrl,
            ev.baselinePath && ev.candidatePath ? { baselinePath: ev.baselinePath, candidatePath: ev.candidatePath } : {}
          );

          similarity = validation.similarity;
          // Delta and no-improvement tracking
          if (typeof this.__prevSim === 'undefined') this.__prevSim = 0;
          const delta = +(similarity - this.__prevSim).toFixed(2);
          this.__prevSim = similarity;

          // Track this iteration with dashboard
          this.hooks.onIteration(phaseNumber, {
            iteration: iterations,
            similarity: similarity,
            duration: new Date() - iterationStart,
            changes: this.generatePhaseChanges(phaseNumber, iterations).concat([`Î” similarity: ${delta >= 0 ? '+' : ''}${delta}%`])
          });

          // Collect improvements and issues
          if (validation.success) {
            improvements.push(`Achieved ${similarity}% similarity`);
          }

          if (validation.issues && validation.issues.length > 0) {
            issues.push(...validation.issues.map(issue => issue.description));
          }

        } else {
          // Design brief phase - use simulated similarity
          similarity = phase.targetSimilarity;

          this.hooks.onIteration(phaseNumber, {
            iteration: iterations,
            similarity: similarity,
            duration: new Date() - iterationStart,
            changes: ['Design brief generated', 'Analysis complete']
          });

          improvements.push('Design brief generated successfully');
        }

        // Break if target achieved
        if (similarity >= phase.targetSimilarity) {
          console.log(`   âœ… Target achieved: ${similarity}%`);
          break;
        }

        // Break if no significant improvement
        if (iterations > 1 && similarity < phase.minProgress) {
          console.log(`   âš ï¸ Insufficient progress, continuing to next phase`);
          break;
        }

      } catch (error) {
        console.error(`   âŒ Iteration ${iterations} failed: ${error.message}`);
        issues.push(`Iteration ${iterations}: ${error.message}`);

        // Still track the failed iteration
        this.hooks.onIteration(phaseNumber, {
          iteration: iterations,
          similarity: similarity,
          duration: new Date() - iterationStart,
          changes: [`Error: ${error.message}`]
        });
      }

      // Brief delay between iterations
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    const success = similarity >= phase.targetSimilarity;
    if (!success && iterations >= maxIterations) {
      issues.push(`CRITICAL_FAIL: Max iterations (${maxIterations}) reached`);
    }

    return {
      success: success,
      similarity: similarity,
      iterations: iterations,
      improvements: improvements,
      issues: issues
    };
  }

  // Execute performance phase (Phase 11)
  async executePerformancePhase(projectPath) {
    console.log('   ðŸš€ Running Enterprise Performance Analysis...');

    try {
      const performanceResults = await this.performanceAnalyzer.executePhase11(
        projectPath,
        'http://localhost:3000'
      );

      return {
        success: performanceResults.passed,
        overallGrade: performanceResults.overallGrade,
        improvements: this.extractPerformanceImprovements(performanceResults),
        issues: this.extractPerformanceIssues(performanceResults)
      };

    } catch (error) {
      return {
        success: false,
        overallGrade: 'FAILED',
        improvements: [],
        issues: [error.message]
      };
    }
  }

  // Execute actual phase logic (placeholder for real implementation)
  async executePhaseLogic(phaseNumber, iteration, projectPath) {
    // Simulate different phase work
    const workDuration = 1000 + Math.random() * 2000; // 1-3 seconds

    await new Promise(resolve => setTimeout(resolve, workDuration));

    console.log(`     ${this.getPhaseWorkDescription(phaseNumber, iteration)}`);
  }

  // Get phase work description
  getPhaseWorkDescription(phaseNumber, iteration) {
    const descriptions = {
      1: ['ðŸ“‹ Analyzing website structure', 'ðŸŽ¨ Extracting design tokens', 'ðŸ“Š Generating design brief'],
      2: ['ðŸ—ï¸ Creating HTML structure', 'ðŸ“ Setting up layout grid', 'ðŸ”§ Configuring build system'],
      3: ['ðŸŽ¨ Applying base styles', 'ðŸŒˆ Implementing color system', 'ðŸ“ Setting up typography'],
      4: ['ðŸ§© Building UI components', 'ðŸ”˜ Creating buttons/forms', 'ðŸ“¦ Component organization'],
      5: ['âš¡ Adding interactivity', 'ðŸŽ¯ Event handling', 'ðŸ“± User interactions'],
      6: ['ðŸ“± Responsive breakpoints', 'ðŸ”§ Mobile optimization', 'ðŸ“ Layout adjustments'],
      7: ['âœ¨ Animation implementation', 'ðŸŽ­ Transition effects', 'âš¡ Performance tuning'],
      8: ['ðŸ’Ž Visual refinements', 'ðŸ” Detail improvements', 'ðŸŽ¨ Final polish'],
      9: ['ðŸ“š ShadCN integration', 'ðŸ”§ Professional components', 'âš¡ Library optimization'],
      10: ['ðŸŽ¯ Comprehensive testing', 'ðŸ” Final validation', 'ðŸ“Š Quality assurance']
    };

    const phaseDescriptions = descriptions[phaseNumber] || ['ðŸ”§ Processing...'];
    return phaseDescriptions[iteration - 1] || phaseDescriptions[0];
  }

  // Generate phase-specific changes
  generatePhaseChanges(phaseNumber, iteration) {
    const changes = {
      1: ['Color palette', 'Typography analysis', 'Layout structure'],
      2: ['HTML skeleton', 'Container setup', 'Grid system'],
      3: ['CSS variables', 'Base styling', 'Color implementation'],
      4: ['Component library', 'UI elements', 'Interactive components'],
      5: ['Event handlers', 'State management', 'User interactions'],
      6: ['Responsive design', 'Mobile layout', 'Breakpoint optimization'],
      7: ['Animations', 'Transitions', 'Motion effects'],
      8: ['Visual polish', 'Detail refinements', 'Bug fixes'],
      9: ['Professional components', 'ShadCN integration', 'Library upgrades'],
      10: ['Validation fixes', 'Quality improvements', 'Final optimizations']
    };

    const phaseChanges = changes[phaseNumber] || ['General improvements'];
    return [phaseChanges[iteration - 1] || 'Refinements'];
  }

  // Get phase definitions
  getPhaseDefinitions() {
    return [
      { name: 'Design Brief Generation', targetSimilarity: 85, minProgress: 80, maxIterations: 2, required: true },
      { name: 'Structural Foundation', targetSimilarity: 30, minProgress: 25, maxIterations: 3, required: true },
      { name: 'Core Styling System', targetSimilarity: 45, minProgress: 35, maxIterations: 3, required: true },
      { name: 'Component Implementation', targetSimilarity: 60, minProgress: 50, maxIterations: 4, required: true },
      { name: 'Interactive Elements', targetSimilarity: 70, minProgress: 60, maxIterations: 3, required: false },
      { name: 'Responsive Design', targetSimilarity: 75, minProgress: 65, maxIterations: 3, required: false },
      { name: 'Animation Integration', targetSimilarity: 80, minProgress: 70, maxIterations: 3, required: false },
      { name: 'Polish & Refinement', targetSimilarity: 85, minProgress: 75, maxIterations: 4, required: false },
      { name: 'Professional Libraries', targetSimilarity: 90, minProgress: 80, maxIterations: 3, required: false },
      { name: 'Comprehensive Validation', targetSimilarity: 94, minProgress: 85, maxIterations: 3, required: false },
      { name: 'Enterprise Performance', targetSimilarity: null, minProgress: null, maxIterations: 1, required: false }
    ];
  }

  // Helper functions
  extractProjectName(url) {
    try {
      const urlObj = new URL(url);
      const domain = urlObj.hostname.replace('www.', '');
      return domain.split('.')[0] + '-protocol30-clone';
    } catch (error) {
      return 'website-protocol30-clone-' + Date.now();
    }
  }

  generateProjectPath(projectName) {
    const path = require('path');
    return path.join(process.cwd(), 'projects', projectName);
  }

  async ensureProjectDirectory(projectPath) {
    const fs = require('fs').promises;
    try {
      await fs.mkdir(projectPath, { recursive: true });
    } catch (error) {
      // Directory might already exist
    }
  }

  extractPerformanceIssues(performanceResults) {
    const issues = [];
    if (performanceResults.performance && performanceResults.performance.issues) {
      issues.push(...performanceResults.performance.issues);
    }
    if (performanceResults.security && performanceResults.security.issues) {
      issues.push(...performanceResults.security.issues);
    }
    if (performanceResults.accessibility && performanceResults.accessibility.issues) {
      issues.push(...performanceResults.accessibility.issues);
    }
    return issues;
  }

  extractPerformanceImprovements(performanceResults) {
    const improvements = [];
    if (performanceResults.performance && performanceResults.performance.score >= 80) {
      improvements.push(`Performance score: ${performanceResults.performance.score}/100`);
    }
    if (performanceResults.security && performanceResults.security.score >= 80) {
      improvements.push(`Security score: ${performanceResults.security.score}/100`);
    }
    if (performanceResults.accessibility && performanceResults.accessibility.score >= 80) {
      improvements.push(`Accessibility: ${performanceResults.accessibility.wcagLevel} compliant`);
    }
    return improvements;
  }
}

// Main execution function with automatic dashboard
async function executeProtocol30(targetUrl, options = {}) {
  const protocol = new IntegratedProtocol30();
  return await protocol.cloneWebsite(targetUrl, options);
}

// Export both class and execution function
module.exports = {
  IntegratedProtocol30,
  executeProtocol30
};

