# Forge Issue Generator
# Converts PRD features into atomic GitHub issues

function Get-FeaturesFromPrd {
    param([string]$PrdPath)

    if (-not (Test-Path $PrdPath)) {
        throw "PRD file not found: $PrdPath"
    }

    $content = Get-Content $PrdPath -Raw
    $features = @()

    # Split by ## headers and find Features section (same as semantic validator)
    $sections = $content -split '(?m)^##\s+'
    $featureSection = $null

    foreach ($section in $sections) {
        if ($section -match "(?i)^[^\n]*(Features|Requirements)[^\n]*") {
            $featureSection = $section
            break
        }
    }

    if ($featureSection) {

        # Extract each feature (#### headers)
        $featureMatches = [regex]::Matches($featureSection, "####\s+(.+?)(?=####|\z)", [System.Text.RegularExpressions.RegexOptions]::Singleline)

        foreach ($match in $featureMatches) {
            $featureText = $match.Groups[1].Value.Trim()

            # Extract feature name (first line)
            $lines = $featureText -split "`n"
            $featureName = $lines[0].Trim()

            # Extract description and acceptance criteria
            $description = ""
            $acceptanceCriteria = @()

            $inCriteria = $false
            foreach ($line in $lines[1..($lines.Length-1)]) {
                if ($line -match "Acceptance Criteria") {
                    $inCriteria = $true
                    continue
                }

                if ($inCriteria -and $line -match "^\s*- \[[ x]\]\s*(.+)") {
                    $acceptanceCriteria += $matches[1].Trim()
                } elseif (-not $inCriteria -and $line.Trim()) {
                    $description += $line.Trim() + " "
                }
            }

            if ($featureName) {
                $features += @{
                    name = $featureName
                    description = $description.Trim()
                    acceptanceCriteria = $acceptanceCriteria
                }
            }
        }
    }

    return $features
}

function New-GitHubIssue {
    param(
        [string]$Title,
        [string]$Body,
        [string[]]$Labels = @("enhancement")
    )

    # Build gh CLI command
    $labelArgs = $Labels | ForEach-Object { "--label `"$_`"" }
    $command = "gh issue create --title `"$Title`" --body `"$Body`" $($labelArgs -join ' ')"

    try {
        $result = Invoke-Expression $command
        return $result
    } catch {
        throw "Failed to create issue: $($_.Exception.Message)"
    }
}

function ConvertTo-GitHubIssue {
    param([hashtable]$Feature)

    $title = $Feature.name

    # Build issue body
    $body = @"
## Feature Description

$($Feature.description)

## Acceptance Criteria

"@

    foreach ($criterion in $Feature.acceptanceCriteria) {
        $body += "- [ ] $criterion`n"
    }

    $body += @"

---

*Generated by Forge v1.0*
"@

    return @{
        title = $title
        body = $body
    }
}

function Invoke-IssueGeneration {
    param([string]$PrdPath)

    # Extract features from PRD
    $features = Get-FeaturesFromPrd -PrdPath $PrdPath

    if ($features.Count -eq 0) {
        throw "No features found in PRD. Make sure your PRD has a '## Features' section with '####' feature headers."
    }

    Write-Host "Found $($features.Count) features in PRD" -ForegroundColor Green
    Write-Host ""

    $createdIssues = @()

    foreach ($feature in $features) {
        Write-Host "Creating issue: $($feature.name)..." -NoNewline

        $issue = ConvertTo-GitHubIssue -Feature $feature

        try {
            $result = New-GitHubIssue -Title $issue.title -Body $issue.body
            Write-Host " [OK]" -ForegroundColor Green
            $createdIssues += @{
                feature = $feature.name
                url = $result
            }
        } catch {
            Write-Host " [FAILED]" -ForegroundColor Red
            Write-Host "  Error: $($_.Exception.Message)" -ForegroundColor Red
        }
    }

    return $createdIssues
}
